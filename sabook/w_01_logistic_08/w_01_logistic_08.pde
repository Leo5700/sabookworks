/*

 Так.
 
 Иногда ты ешь медведя, иногда медведь есть тебя.
 
 Сегодня я хотел создать логистическое дерево в трёх сферических координатах --
 что же в итоге? Полное и безоговорочное нихуя, того, что опишет дерево просто
 нет, нет технически -- но есть ли математически? Если есть идеи, как
 превратить диаграмму Фейгенбаума в трёхмерное дерево с изменчивой "листвой"
 при R > 3.8, вы не задумывайтесь, пишите код и/или пишите мне.
 
 А пока, всё идёт как идёт, опишем строки кода, это ...
 
 */


float deg = PI / 180; // это крайне удобная константа, классика своего рода,
// позволяет задавать углы в градусах: 
// 180*deg, 360*deg и так далее.


void setup() { // всё подряд, setup это нулевая итерация, как бы нулевой кадр
  // мультфильма

  //size(1080, 1080); // это размер окна, в пикселях, сейчас не нужно, но может
  //пригодиться

  fullScreen(); // здесь мы разворачиваем картинку на полный экран, поставив в
  // скобках номер монитора, можно отправить картинку на конкретный экран, задав
  // номер экрана командой вида "fullscreen(1)", где 1 это номер экрана, но
  //  работает это не везде и не всегда, таков processing, это bugness old way

  background(0); // первый  экран зальём чёрным (цвет ноль), хотя это и не
  // нужно, это хороший тон

  stroke(255, 200); // цвет отрисовки контуров, 255 это белый, 200 это
  // прозрачность (200 это почти не прозрачный, т.к. 255 не прозрачный вовсе)

  strokeWeight(1); // толщина линий, точки это тоже линии, так что это размер
  // точек

  noCursor(); // не показывать курсор мыши (под android это не нужно, но в
  // винде, линуксе и яблоке это пригодится)
}


void draw() {

  backAlpha(0, 80); // это функция (смотри ниже), которая заливает экран
  // полупрозрачным фоном, позволяет получить картинку, слегка растянутую по
  // континуму пространства-времени (не плохо, правда?)

  int k = 6; // это ... число сегментов паттерна итоговой картинки по базовому
  // углу. нет, давай так: число повторений.. хотя это не совсем повторения..
  // (вот ёклмн самое простое хрен опишешь), поменяй посмотри на что влияет и
  // делов-то. 

  translate(width*.5, height*.5); // переносим начало координат в центр экрана

  for (int i=0; i<k; i++) { // k итераций do:

    pushMatrix(); // так, ищи где на том же уровне popMatrix, это начало от
    // сдвига координат, для того, чтобы вернуть систему координат обратно, не
    // путайся, таких финтов тут два

    rotate((TWO_PI / k) * i); // поворачиваем систему координат на некоторый
    // угол, один из k

    float R0 = 3; // это стартовое значение засыпки коэффициента R. Царица
    // Небесная, как далеко ещё до Петушков

    float R1 = 4; // это коэффициент в логистическом уравнении

    float sh = sin((frameCount * .01) + i) * 0.5 + 0.5; // а вот здесь мы делаем
    // финт: 
    // с одной стороны заставляем опорную координату (это ничего что я начал
    // вводить термины без определений? опорная координата это нечто, влияющее на
    // анимацию в целом, мы ведь здесь рисуем мультики, мультики, первым делом
    // мультики и больше ничего, а во вторых изучаем математику бытия (но это не
    // точно); 
    // кстати, не сочтите за пошлость, я проведу параллель с функцией
    // Эрвина Шреденгира, коллапсирующей в конечное решение. Так вот, посмотрите
    // внимательно: из математики копеечного логистического аттрактора не следует
    // ли, что в каждой точке итерирования функции calcLog мы с вами оказываемся в
    // коробке рядом с кошкой Шрёдингера? Для более глубокого погружения в вопрос, 
    // нам с вами понадобится толика пива и лекция тов. Семихатова о том что
    // можно, а что нельзя в квантовой реальности https://youtu.be/bOi6OAwCNH4 

    //float x0 = map(i, 0, k, 0.01, 0.99); //это не интересно

    float x0 = sh; // sh это "shift", то есть "сдвиг", переменная, которая
    // толкает нас вдоль по континууму, исходное значение X мы берём именно это

    for (PVector r : calcLog(x0, R0, R1, 2000)) { // вычисляем значение функции
      // (она ниже) и итерируемся по ней, кстати, PVector это классный объект для
      // хранения координат, подробнее ищи "PVector processing"

      pushMatrix(); // снова локализуем смещение координат (до popMatrix
      // () ниже)

      float a = map(r.y, 0, 1, -20*deg, 30*deg); // это угол поворота местной
      // системы координат, можно было сделать то же через синусы и косинусы, но
      // вращением координат несколько элегантнее

      rotate(a); // вращаемся

      point(map(r.x, R0, R1, 0, 360), 0); // выводим на экран точку, всё здесь
      // из точек, по крайней мере пока

      popMatrix(); // возвращаем координаты на место
    }

    popMatrix(); // возвращаем на место координаты ещё раз
  }
}



PVector[] calcLog(float x0, float Rmin, float Rmax, int n) { // пишем функцию,
  // которая будет возвращать массив точек - решений уравнения 

  // x0 - начальное значение Rmin, Rmax - диапазон коэффициента R m - длина
  // массива результатов На выходе: массив объектов типа PVector, координаты
  // PVector: R, x (к которому сошлось решение), x0

  PVector[] result = new PVector[n]; // терпение и труд всё я устал


  for (int j=0; j<n; j++) { 
    float x = x0; 
    float R; 
    float x_new; 
    R = random
      (Rmin, Rmax); 
    for (int i=0; i<500; i++) { // итерации до сходимости x_new =
      x_new = R * x * (1 - x); // логистическое уравнение 
      x = x_new;
    } 
    PVector pv = new PVector(R, x, x0); 
    result[j] = pv;
  }

  return result;
}


void backAlpha(float c, float a) {

  // заливаем экран прозрачным фоном, это по большому счёту костыль, связанный с
  // тем, что processing не умеет заливать полупрозрачный бэкграунд функцией
  // background (0, 42); кстати сказать, андроидовское окружение APDE
  // https://github.com/Calsign/APDE это умеет  

  pushStyle(); 
  noStroke(); 
  fill(c, a); 
  rect(0, 0, width, height); 
  popStyle();
}


/* 
 
 Есть-ли что ни будь на земле, что имело бы значение и могло бы даже изменить ход
 событий не только на земле, но и в других мирах? — спросил я своего учителя.
 Есть, — ответил мне мой учитель. Что же это? — спросил я. Это... — начал мой
 учитель и вдруг замолчал. Я стоял и напряженно ждал его ответа. А он молчал. И
 я стоял и молчал. И он молчал. И я стоял и молчал. И он молчал. Мы оба стоим и
 молчим. Хо-ля-ля! Мы оба стоим и молчим! Хо-ля-ля! Да да, мы оба стоим и
 молчим!
 
 Д. Ювачев
 
 Вообще, я тут много кого цитировал и авторов не упоминал, да простит меня
 читатель. Впрочем, и Ювачев известен не как Ювачев. Давайте-ка приведу список
 (не полный) всех тех, кого цитирую, хотя и местами перефразирую:
 * Д. Хармс (настоящая фамилия Ювачев)
 * В. Ерофеев
 * И. Летов (он же Е. Летов)
 * И. Кормильцев (или В. Бутусов)
 * вроде всё, что-то ещё было из Конфуция, Кастанеды (врочем, он об этом ничего
 не писал), также Дуглас Хофштадтер и его Эшер, Гёдель
 и Вольфганг Амадей Бах, также, Джоэл и Итэн Коэны.
 
 */
 
 
 
 
 
 
 
 
 /*
 
 Послесловие. Дружище, если ты домотал до этих строк, знай: это было тяжело.
 Коментить каждую строчку кода -- это бляёбаныйчерезтриколенапиздорот тяжело.
 Спасибо тебе. Два дня и 6 (шесть) стаканов пива "GBF" в Крафтейнере на Флаконе 
 я потратил на это. И впредь мы этого делать не будем. Повторяю по буквам: 
 Нина, Иван, Харитон, Ульяна, Яна.
 
 */
 
